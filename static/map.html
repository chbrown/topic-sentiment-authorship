<!DOCTYPE html>
<head>
  <!-- http://ghkl/tsa/static/map.html -->
  <!-- http://rawgit.com/chbrown/tsa/master/static/map.html -->
  <meta charset='utf-8'>
  <title>Ohio Map</title>
</head>
<body ng-app="app" ng-controller="mapCtrl">
  <nav>
    <div style="font-size: 90%">
      <label style="display: none">
        <input type="checkbox" ng-model="$storage.for_against"> Tweets
      </label>

      <div><b>Label source</b></div>
      <select ng-model="$storage.tweets_property"
        ng-options="opt.value as opt.key for opt in tweets_properties"></select>

      <div><b>Scaling factor</b>
        <label>
          <input type="checkbox" ng-model="$storage.scale_log"> log
        </label>
      </div>
      <select ng-model="$storage.scale_factor"
        ng-options="opt.value as opt.key for opt in scale_factors"></select>
      </label>
    </div>
  </nav>
  <svg downloadable style="border: 1px solid #ddd;">
    <style type="text/css">
    path {
      fill: none;
    }
    path.mesh {
      stroke-width: .5px;
      stroke: black;
    }
    </style>
  </svg>
</body>

<script src="./lib/underscore.min.js"></script>
<script src="./lib/angular.min.js"></script>
<script src="./lib/ngStorage.min.js"></script>
<script src="./lib/d3.min.js"></script>
<script src="./lib/topojson.js"></script>
<script>
function download(blob, filename) {
  // window.href = object_url;
  // window.open(object_url, '_blank', '');
  // var blob = new Blob([req.response], {type:  'application/pdf'});
  var object_url = window.URL.createObjectURL(blob);

  var a = document.createElement('a');
  a.setAttribute('href', object_url);
  a.setAttribute('download', filename);
  a.dispatchEvent(new MouseEvent('click'));

  window.URL.revokeObjectURL(object_url);
}

function render_svg(svg) {
  req = new XMLHttpRequest()
  req.open('POST', 'http://localhost:1151/');
  req.setRequestHeader('X-Args', '-f pdf');
  req.responseType = 'blob';
  req.send(svg);
  req.onreadystatechange = function() {
    if (req.readyState == 4) {
      download(req.response, 'map.pdf');
    }
  };
}

var width = 700,
    height = 700;

// var projection = path.projection();
var projection = d3.geo.mercator()
  .center([-82.7, 40.2]) // somewhere in the middle
  // .center([-82.98, 39.98]) // Columbus
  .scale(8000)
  // .rotate([0, 0])
  .translate([width / 2, height / 2]);

// colorbrewer.RdBu[9]
var for_against_gradient = d3.scale.linear()
  .domain([-1, 0, 1])
  .range(['blue', 'purple', 'red']);

var population_gradient = d3.scale.linear()
  .domain([0, 1000000])
  .range(['white', 'black']);

var path = d3.geo.path()
  .projection(projection);

var svg = d3.select('svg')
    .attr('width', width)
    .attr('height', height);

var app = angular.module('app', ['ngStorage']);
app.controller('mapCtrl', function($scope, $localStorage, $http) {
  $scope.$storage = $localStorage.$default({
    tweets_property: 'tweets',
    scale_factor: 'tweets',
    scale_log: true,
  });

  $scope.tweets_properties = [
    {key: 'All geolocated tweets (after automatic classification)', value: 'tweets'},
    {key: 'Manually labeled tweets', value: 'labeled_tweets'},
  ];
  $scope.scale_factors = [
    {key: 'Census 2010 population', value: 'population'},
    {key: 'Number of tweets', value: 'tweets'},
  ];

  var redraw = function() {
    draw($scope.$storage.tweets_property, $scope.$storage.scale_factor, $scope.$storage.scale_log);
  }

  $scope.$watch('$storage.tweets_property', redraw);
  $scope.$watch('$storage.scale_factor', redraw);
  $scope.$watch('$storage.scale_log', redraw);
  // svg.selectAll('.for_against').style('visibility', val ? 'visible' : 'hidden')
});

app.directive('downloadable', function($http) {
  return {
    link: function(scope, element, attrs) {
      var control = angular.element('<div><button>Download PDF</button></div>');
      control.find('button').on('click', function() {
        var svg = new XMLSerializer().serializeToString(element[0]);
        render_svg(svg);
      });
      element.after(control);
    }
  };
});

function draw(tweets_property, scale_factor, scale_log) {
  // console.log('drawing', tweets_property, scale_factor);
  d3.json('./oh-counties.topo.json', function(err, map) {
    var obj = map.objects['stdin'],
        tf = map.transform,
        kx = tf.scale[0],
        ky = tf.scale[1],
        dx = tf.translate[0],
        dy = tf.translate[1];

    // prepare
    var featureForAgainst = function(feature) {
      var tweets = _.extend({For: 0, Against: 0, Total: 0},
        feature.properties[tweets_property]);
      return tweets.Total == 0 ? undefined : (tweets.For - tweets.Against) / tweets.Total;
    };

    var featureInfo = function(feature) {
      var tweets = _.extend({For: 0, Against: 0, Total: 0}, feature.properties.tweets);
      return [
        feature.id,
        '(For = ' + tweets.For + ')',
        '(Against = ' + tweets.Against + ')',
        '(Pop = ' + feature.properties.population + ')',
      ].join(' ');
    };

    var featureSize = function(feature) {
      if (scale_factor == 'population') {
        return feature.properties.population;
      }
      else {
        return _.extend({Total: 0}, feature.properties[tweets_property]).Total;
      }
    };

    var counties = topojson.feature(map, obj);
    var sizes = counties.features.map(featureSize);
    // starting the domain at 0.5 will give even a single tweet a little bit of weight
    var size_scale = (scale_log ? d3.scale.log() : d3.scale.linear())
      .domain([0.5, d3.max(sizes)])
      .range([0, 1]);

    svg.selectAll('.for_against')
      .data(counties.features)
    .enter().append('path')
      .attr('d', path)
      .attr('class', 'for_against')
      .append('title').text(featureInfo)

    svg.selectAll('.for_against')
      .data(counties.features)
      .style('fill', function(d) {
        var for_against = featureForAgainst(d);
        return for_against ? for_against_gradient(for_against) : 'white';
      })
      .attr('transform', function(d) {
        var centroid = path.centroid(d);
        var dx = centroid[0];
        var dy = centroid[1];
        var size = featureSize(d);
        var scale = size_scale(size);

        var mat = [scale, 0, 0, scale, dx - scale*dx, dy - scale*dy];
        return 'matrix(' + mat.join(',') + ')';
      });

    // the mesh is just a undifferentiated grid of all things on the map
    var mesh = topojson.mesh(map);
    var mesh_path = svg.selectAll('.mesh')
      .data([true])
    .enter().append('path')
      .attr('class', 'mesh')
      .datum(mesh)
      .attr('d', path);
  });
}

// svg.selectAll('.population')
//   .data(counties.features)
// .enter().append('path')
//   .attr('d', function(d) {
//     return path(d)
//   })
//   .attr('class', 'population')
//   .style('fill', function(d) {
//     return population_gradient(d.properties.population);
//   });
</script>
